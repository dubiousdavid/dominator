;; Analyzed by ClojureScript 0.0-3178
{:use-macros nil, :excludes #{remove replace next}, :name clojure.zip, :imports nil, :requires nil, :uses nil, :defs {rightmost {:protocol-inline nil, :meta {:line 142, :column 7, :end-line 142, :end-column 16, :arglists (quote ([loc])), :doc "Returns the loc of the rightmost sibling of the node at this loc, or self", :file nil}, :name clojure.zip/rightmost, :variadic false, :file "mario/clojure/zip.cljs", :end-column 16, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 142, :end-line 142, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Returns the loc of the rightmost sibling of the node at this loc, or self", :test true}, insert-child {:protocol-inline nil, :meta {:line 194, :column 7, :end-line 194, :end-column 19, :arglists (quote ([loc item])), :doc "Inserts the item as the leftmost child of the node at this loc,\n  without moving", :file nil}, :name clojure.zip/insert-child, :variadic false, :file "mario/clojure/zip.cljs", :end-column 19, :method-params ([loc item]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 194, :end-line 194, :max-fixed-arity 2, :fn-var true, :arglists (quote ([loc item])), :doc "Inserts the item as the leftmost child of the node at this loc,\n  without moving", :test true}, left {:protocol-inline nil, :meta {:line 150, :column 7, :end-line 150, :end-column 11, :arglists (quote ([loc])), :doc "Returns the loc of the left sibling of the node at this loc, or nil", :file nil}, :name clojure.zip/left, :variadic false, :file "mario/clojure/zip.cljs", :end-column 11, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 150, :end-line 150, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Returns the loc of the left sibling of the node at this loc, or nil", :test true}, path {:protocol-inline nil, :meta {:line 82, :column 7, :end-line 82, :end-column 11, :arglists (quote ([loc])), :doc "Returns a seq of nodes leading to this loc", :file nil}, :name clojure.zip/path, :variadic false, :file "mario/clojure/zip.cljs", :end-column 11, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 82, :end-line 82, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Returns a seq of nodes leading to this loc", :test true}, leftmost {:protocol-inline nil, :meta {:line 157, :column 7, :end-line 157, :end-column 15, :arglists (quote ([loc])), :doc "Returns the loc of the leftmost sibling of the node at this loc, or self", :file nil}, :name clojure.zip/leftmost, :variadic false, :file "mario/clojure/zip.cljs", :end-column 15, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 157, :end-line 157, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Returns the loc of the leftmost sibling of the node at this loc, or self", :test true}, append-child {:protocol-inline nil, :meta {:line 200, :column 7, :end-line 200, :end-column 19, :arglists (quote ([loc item])), :doc "Inserts the item as the rightmost child of the node at this loc,\n  without moving", :file nil}, :name clojure.zip/append-child, :variadic false, :file "mario/clojure/zip.cljs", :end-column 19, :method-params ([loc item]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 200, :end-line 200, :max-fixed-arity 2, :fn-var true, :arglists (quote ([loc item])), :doc "Inserts the item as the rightmost child of the node at this loc,\n  without moving", :test true}, branch? {:protocol-inline nil, :meta {:line 64, :column 7, :end-line 64, :end-column 14, :arglists (quote ([loc])), :doc "Returns true if the node at loc is a branch", :file nil}, :name clojure.zip/branch?, :variadic false, :file "mario/clojure/zip.cljs", :end-column 14, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 64, :end-line 64, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Returns true if the node at loc is a branch", :test true}, children {:protocol-inline nil, :meta {:line 69, :column 7, :end-line 69, :end-column 15, :arglists (quote ([loc])), :doc "Returns a seq of the children of node at loc, which must be a branch", :file nil}, :name clojure.zip/children, :variadic false, :file "mario/clojure/zip.cljs", :end-column 15, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 69, :end-line 69, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Returns a seq of the children of node at loc, which must be a branch", :test true}, remove {:protocol-inline nil, :meta {:line 237, :column 7, :end-line 237, :end-column 13, :arglists (quote ([loc])), :doc "Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk.", :file nil}, :name clojure.zip/remove, :variadic false, :file "mario/clojure/zip.cljs", :end-column 13, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 237, :end-line 237, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk.", :test true}, down {:protocol-inline nil, :meta {:line 98, :column 7, :end-line 98, :end-column 11, :arglists (quote ([loc])), :doc "Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children", :file nil}, :name clojure.zip/down, :variadic false, :file "mario/clojure/zip.cljs", :end-column 11, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 98, :end-line 98, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children", :test true}, replace {:protocol-inline nil, :meta {:line 183, :column 7, :end-line 183, :end-column 14, :arglists (quote ([loc node])), :doc "Replaces the node at this loc, without moving", :file nil}, :name clojure.zip/replace, :variadic false, :file "mario/clojure/zip.cljs", :end-column 14, :method-params ([loc node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 183, :end-line 183, :max-fixed-arity 2, :fn-var true, :arglists (quote ([loc node])), :doc "Replaces the node at this loc, without moving", :test true}, zipper {:protocol-inline nil, :meta {:line 18, :column 7, :end-line 18, :end-column 13, :arglists (quote ([branch? children make-node root])), :doc "Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node.", :file nil}, :name clojure.zip/zipper, :variadic false, :file "mario/clojure/zip.cljs", :end-column 13, :method-params ([branch? children make-node root]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 18, :end-line 18, :max-fixed-arity 4, :fn-var true, :arglists (quote ([branch? children make-node root])), :doc "Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node.", :test true}, end? {:protocol-inline nil, :meta {:line 232, :column 7, :end-line 232, :end-column 11, :arglists (quote ([loc])), :doc "Returns true if loc represents the end of a depth-first walk", :file nil}, :name clojure.zip/end?, :variadic false, :file "mario/clojure/zip.cljs", :end-column 11, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 232, :end-line 232, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Returns true if loc represents the end of a depth-first walk", :test true}, edit {:protocol-inline nil, :meta {:line 189, :column 7, :end-line 189, :end-column 11, :arglists (quote ([loc f & args])), :doc "Replaces the node at this loc with the value of (f node args)", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(loc f args)], :arglists [[loc f & args]], :arglists-meta (nil)}, :file nil}, :name clojure.zip/edit, :variadic true, :file "mario/clojure/zip.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(loc f args)], :arglists [[loc f & args]], :arglists-meta (nil)}, :method-params [(loc f args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 189, :end-line 189, :max-fixed-arity 2, :fn-var true, :arglists [[loc f & args]], :doc "Replaces the node at this loc with the value of (f node args)", :test true}, make-node {:protocol-inline nil, :meta {:line 76, :column 7, :end-line 76, :end-column 16, :arglists (quote ([loc node children])), :doc "Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor.", :file nil}, :name clojure.zip/make-node, :variadic false, :file "mario/clojure/zip.cljs", :end-column 16, :method-params ([loc node children]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 76, :end-line 76, :max-fixed-arity 3, :fn-var true, :arglists (quote ([loc node children])), :doc "Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor.", :test true}, vector-zip {:protocol-inline nil, :meta {:line 42, :column 7, :end-line 42, :end-column 17, :arglists (quote ([root])), :doc "Returns a zipper for nested vectors, given a root vector", :file nil}, :name clojure.zip/vector-zip, :variadic false, :file "mario/clojure/zip.cljs", :end-column 17, :method-params ([root]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 42, :end-line 42, :max-fixed-arity 1, :fn-var true, :arglists (quote ([root])), :doc "Returns a zipper for nested vectors, given a root vector", :test true}, node {:protocol-inline nil, :meta {:line 60, :column 7, :end-line 60, :end-column 11, :arglists (quote ([loc])), :doc "Returns the node at loc", :file nil}, :name clojure.zip/node, :variadic false, :file "mario/clojure/zip.cljs", :end-column 11, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 60, :end-line 60, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Returns the node at loc", :test true}, up {:protocol-inline nil, :meta {:line 111, :column 7, :end-line 111, :end-column 9, :arglists (quote ([loc])), :doc "Returns the loc of the parent of the node at this loc, or nil if at\n  the top", :file nil}, :name clojure.zip/up, :variadic false, :file "mario/clojure/zip.cljs", :end-column 9, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 111, :end-line 111, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Returns the loc of the parent of the node at this loc, or nil if at\n  the top", :test true}, insert-right {:protocol-inline nil, :meta {:line 174, :column 7, :end-line 174, :end-column 19, :arglists (quote ([loc item])), :doc "Inserts the item as the right sibling of the node at this loc,\n  without moving", :file nil}, :name clojure.zip/insert-right, :variadic false, :file "mario/clojure/zip.cljs", :end-column 19, :method-params ([loc item]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 174, :end-line 174, :max-fixed-arity 2, :fn-var true, :arglists (quote ([loc item])), :doc "Inserts the item as the right sibling of the node at this loc,\n  without moving", :test true}, rights {:protocol-inline nil, :meta {:line 92, :column 7, :end-line 92, :end-column 13, :arglists (quote ([loc])), :doc "Returns a seq of the right siblings of this loc", :file nil}, :name clojure.zip/rights, :variadic false, :file "mario/clojure/zip.cljs", :end-column 13, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 92, :end-line 92, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Returns a seq of the right siblings of this loc", :test true}, root {:protocol-inline nil, :meta {:line 124, :column 7, :end-line 124, :end-column 11, :arglists (quote ([loc])), :doc "zips all the way up and returns the root node, reflecting any\n changes.", :file nil}, :name clojure.zip/root, :variadic false, :file "mario/clojure/zip.cljs", :end-column 11, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 124, :end-line 124, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "zips all the way up and returns the root node, reflecting any\n changes.", :test true}, next {:protocol-inline nil, :meta {:line 206, :column 7, :end-line 206, :end-column 11, :arglists (quote ([loc])), :doc "Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there.", :file nil}, :name clojure.zip/next, :variadic false, :file "mario/clojure/zip.cljs", :end-column 11, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 206, :end-line 206, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there.", :test true}, seq-zip {:protocol-inline nil, :meta {:line 34, :column 7, :end-line 34, :end-column 14, :arglists (quote ([root])), :doc "Returns a zipper for nested sequences, given a root sequence", :file nil}, :name clojure.zip/seq-zip, :variadic false, :file "mario/clojure/zip.cljs", :end-column 14, :method-params ([root]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 34, :end-line 34, :max-fixed-arity 1, :fn-var true, :arglists (quote ([root])), :doc "Returns a zipper for nested sequences, given a root sequence", :test true}, insert-left {:protocol-inline nil, :meta {:line 165, :column 7, :end-line 165, :end-column 18, :arglists (quote ([loc item])), :doc "Inserts the item as the left sibling of the node at this loc,\n without moving", :file nil}, :name clojure.zip/insert-left, :variadic false, :file "mario/clojure/zip.cljs", :end-column 18, :method-params ([loc item]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 165, :end-line 165, :max-fixed-arity 2, :fn-var true, :arglists (quote ([loc item])), :doc "Inserts the item as the left sibling of the node at this loc,\n without moving", :test true}, prev {:protocol-inline nil, :meta {:line 221, :column 7, :end-line 221, :end-column 11, :arglists (quote ([loc])), :doc "Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil.", :file nil}, :name clojure.zip/prev, :variadic false, :file "mario/clojure/zip.cljs", :end-column 11, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 221, :end-line 221, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil.", :test true}, right {:protocol-inline nil, :meta {:line 135, :column 7, :end-line 135, :end-column 12, :arglists (quote ([loc])), :doc "Returns the loc of the right sibling of the node at this loc, or nil", :file nil}, :name clojure.zip/right, :variadic false, :file "mario/clojure/zip.cljs", :end-column 12, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 135, :end-line 135, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Returns the loc of the right sibling of the node at this loc, or nil", :test true}, lefts {:protocol-inline nil, :meta {:line 87, :column 7, :end-line 87, :end-column 12, :arglists (quote ([loc])), :doc "Returns a seq of the left siblings of this loc", :file nil}, :name clojure.zip/lefts, :variadic false, :file "mario/clojure/zip.cljs", :end-column 12, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 87, :end-line 87, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Returns a seq of the left siblings of this loc", :test true}, xml-zip {:protocol-inline nil, :meta {:line 50, :column 7, :end-line 50, :end-column 14, :arglists (quote ([root])), :doc "Returns a zipper for xml elements (as from xml/parse),\n  given a root element", :file nil}, :name clojure.zip/xml-zip, :variadic false, :file "mario/clojure/zip.cljs", :end-column 14, :method-params ([root]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 50, :end-line 50, :max-fixed-arity 1, :fn-var true, :arglists (quote ([root])), :doc "Returns a zipper for xml elements (as from xml/parse),\n  given a root element", :test true}}, :require-macros nil, :cljs.analyzer/constants {:seen #{:ppath :zip/branch? :r :zip/children :content :l :zip/make-node :pnodes :changed? :end}, :order [:zip/branch? :zip/children :zip/make-node :content :pnodes :l :r :ppath :changed? :end]}, :doc "Functional hierarchical zipper, with navigation, editing,\n  and enumeration.  See Huet"}