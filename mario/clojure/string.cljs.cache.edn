;; Analyzed by ClojureScript 0.0-3178
{:use-macros nil, :excludes #{reverse replace}, :name clojure.string, :imports {StringBuffer goog.string.StringBuffer}, :requires {gstring goog.string, goog.string goog.string, StringBuffer goog.string.StringBuffer}, :uses nil, :defs {seq-reverse {:protocol-inline nil, :meta {:line 14, :column 8, :end-line 14, :end-column 19, :private true, :arglists (quote ([coll])), :file nil}, :private true, :name clojure.string/seq-reverse, :variadic false, :file "mario/clojure/string.cljs", :end-column 19, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 14, :end-line 14, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :test true}, capitalize {:protocol-inline nil, :meta {:line 78, :column 7, :end-line 78, :end-column 17, :arglists (quote ([s])), :doc "Converts first character of the string to upper-case, all other\n  characters to lower-case.", :file nil}, :name clojure.string/capitalize, :variadic false, :file "mario/clojure/string.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 78, :end-line 78, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Converts first character of the string to upper-case, all other\n  characters to lower-case.", :test true}, reverse {:protocol-inline nil, :meta {:line 21, :column 7, :end-line 21, :end-column 14, :arglists (quote ([s])), :doc "Returns s with its characters reversed.", :file nil}, :name clojure.string/reverse, :variadic false, :file "mario/clojure/string.cljs", :end-column 14, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 21, :end-line 21, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Returns s with its characters reversed.", :test true}, join {:protocol-inline nil, :meta {:line 49, :column 7, :end-line 49, :end-column 11, :arglists (quote ([coll] [separator coll])), :doc "Returns a string of all elements in coll, as returned by (seq coll),\n  separated by an optional separator.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [separator coll]), :arglists ([coll] [separator coll]), :arglists-meta (nil nil)}, :file nil}, :name clojure.string/join, :variadic false, :file "mario/clojure/string.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [separator coll]), :arglists ([coll] [separator coll]), :arglists-meta (nil nil)}, :method-params ([coll] [separator coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 49, :end-line 49, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [separator coll]), :doc "Returns a string of all elements in coll, as returned by (seq coll),\n  separated by an optional separator.", :test true}, replace-first {:protocol-inline nil, :meta {:line 40, :column 7, :end-line 40, :end-column 20, :arglists (quote ([s match replacement])), :doc "Replaces the first instance of match with replacement in s.\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).", :file nil}, :name clojure.string/replace-first, :variadic false, :file "mario/clojure/string.cljs", :end-column 20, :method-params ([s match replacement]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 40, :end-line 40, :max-fixed-arity 3, :fn-var true, :arglists (quote ([s match replacement])), :doc "Replaces the first instance of match with replacement in s.\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).", :test true}, escape {:protocol-inline nil, :meta {:line 179, :column 7, :end-line 179, :end-column 13, :arglists (quote ([s cmap])), :doc "Return a new string, using cmap to escape each character ch\n   from s as follows:\n\n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.", :file nil}, :name clojure.string/escape, :variadic false, :file "mario/clojure/string.cljs", :end-column 13, :method-params ([s cmap]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 179, :end-line 179, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s cmap])), :doc "Return a new string, using cmap to escape each character ch\n   from s as follows:\n\n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.", :test true}, discard-trailing-if-needed {:protocol-inline nil, :meta {:line 103, :column 8, :end-line 103, :end-column 34, :private true, :arglists (quote ([limit v])), :file nil}, :private true, :name clojure.string/discard-trailing-if-needed, :variadic false, :file "mario/clojure/string.cljs", :end-column 34, :method-params ([limit v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 103, :end-line 103, :max-fixed-arity 2, :fn-var true, :arglists (quote ([limit v])), :test true}, pop-last-while-empty {:protocol-inline nil, :meta {:line 96, :column 8, :end-line 96, :end-column 28, :private true, :arglists (quote ([v])), :file nil}, :private true, :name clojure.string/pop-last-while-empty, :variadic false, :file "mario/clojure/string.cljs", :end-column 28, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 96, :end-line 96, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :test true}, replace {:protocol-inline nil, :meta {:line 27, :column 7, :end-line 27, :end-column 14, :arglists (quote ([s match replacement])), :doc "Replaces all instance of match with replacement in s.\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).", :file nil}, :name clojure.string/replace, :variadic false, :file "mario/clojure/string.cljs", :end-column 14, :method-params ([s match replacement]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 27, :end-line 27, :max-fixed-arity 3, :fn-var true, :arglists (quote ([s match replacement])), :doc "Replaces all instance of match with replacement in s.\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).", :test true}, split-lines {:protocol-inline nil, :meta {:line 142, :column 7, :end-line 142, :end-column 18, :arglists (quote ([s])), :doc "Splits s on \n or \r\n.", :file nil}, :name clojure.string/split-lines, :variadic false, :file "mario/clojure/string.cljs", :end-column 18, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 142, :end-line 142, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Splits s on \n or \r\n.", :test true}, lower-case {:protocol-inline nil, :meta {:line 73, :column 7, :end-line 73, :end-column 17, :arglists (quote ([s])), :doc "Converts string to all lower-case.", :file nil}, :name clojure.string/lower-case, :variadic false, :file "mario/clojure/string.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 73, :end-line 73, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Converts string to all lower-case.", :test true}, trim-newline {:protocol-inline nil, :meta {:line 162, :column 7, :end-line 162, :end-column 19, :arglists (quote ([s])), :doc "Removes all trailing newline \\n or return \\r characters from\n  string.  Similar to Perl's chomp.", :file nil}, :name clojure.string/trim-newline, :variadic false, :file "mario/clojure/string.cljs", :end-column 19, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 162, :end-line 162, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Removes all trailing newline \\n or return \\r characters from\n  string.  Similar to Perl's chomp.", :test true}, upper-case {:protocol-inline nil, :meta {:line 68, :column 7, :end-line 68, :end-column 17, :arglists (quote ([s])), :doc "Converts string to all upper-case.", :file nil}, :name clojure.string/upper-case, :variadic false, :file "mario/clojure/string.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 68, :end-line 68, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Converts string to all upper-case.", :test true}, split {:protocol-inline nil, :meta {:line 119, :column 7, :end-line 119, :end-column 12, :arglists (quote ([s re] [s re limit])), :doc "Splits string on a regular expression. Optional argument limit is\n  the maximum number of splits. Not lazy. Returns vector of the splits.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([s re] [s re limit]), :arglists ([s re] [s re limit]), :arglists-meta (nil nil)}, :file nil}, :name clojure.string/split, :variadic false, :file "mario/clojure/string.cljs", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([s re] [s re limit]), :arglists ([s re] [s re limit]), :arglists-meta (nil nil)}, :method-params ([s re] [s re limit]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 119, :end-line 119, :max-fixed-arity 3, :fn-var true, :arglists ([s re] [s re limit]), :doc "Splits string on a regular expression. Optional argument limit is\n  the maximum number of splits. Not lazy. Returns vector of the splits.", :test true}, trimr {:protocol-inline nil, :meta {:line 157, :column 7, :end-line 157, :end-column 12, :arglists (quote ([s])), :doc "Removes whitespace from the right side of string.", :file nil}, :name clojure.string/trimr, :variadic false, :file "mario/clojure/string.cljs", :end-column 12, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 157, :end-line 157, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Removes whitespace from the right side of string.", :test true}, trim {:protocol-inline nil, :meta {:line 147, :column 7, :end-line 147, :end-column 11, :arglists (quote ([s])), :doc "Removes whitespace from both ends of string.", :file nil}, :name clojure.string/trim, :variadic false, :file "mario/clojure/string.cljs", :end-column 11, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 147, :end-line 147, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Removes whitespace from both ends of string.", :test true}, triml {:protocol-inline nil, :meta {:line 152, :column 7, :end-line 152, :end-column 12, :arglists (quote ([s])), :doc "Removes whitespace from the left side of string.", :file nil}, :name clojure.string/triml, :variadic false, :file "mario/clojure/string.cljs", :end-column 12, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 152, :end-line 152, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Removes whitespace from the left side of string.", :test true}, blank? {:protocol-inline nil, :meta {:line 174, :column 7, :end-line 174, :end-column 13, :arglists (quote ([s])), :doc "True is s is nil, empty, or contains only whitespace.", :file nil}, :name clojure.string/blank?, :variadic false, :file "mario/clojure/string.cljs", :end-column 13, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 174, :end-line 174, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "True is s is nil, empty, or contains only whitespace.", :test true}, re-surrogate-pair {:name clojure.string/re-surrogate-pair, :line 18, :column 1, :end-line 18, :end-column 33, :private true, :test true, :meta {:line 18, :column 16, :end-line 18, :end-column 33, :private true, :file nil}, :file "mario/clojure/string.cljs"}, split-with-empty-regex {:protocol-inline nil, :meta {:line 109, :column 8, :end-line 109, :end-column 30, :private true, :arglists (quote ([s limit])), :file nil}, :private true, :name clojure.string/split-with-empty-regex, :variadic false, :file "mario/clojure/string.cljs", :end-column 30, :method-params ([s limit]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 109, :end-line 109, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s limit])), :test true}}, :require-macros nil, :cljs.analyzer/constants {:seen #{:else}, :order [:else]}, :doc nil}