;; Analyzed by ClojureScript 0.0-3178
{:use-macros {go cljs.core.async.macros, go-loop cljs.core.async.macros}, :excludes #{map reductions merge count}, :name jamesmacaulay.zelkova.signal, :imports nil, :requires {core cljs.core, cljs.core cljs.core, async cljs.core.async, cljs.core.async cljs.core.async, async-impl cljs.core.async.impl.protocols, cljs.core.async.impl.protocols cljs.core.async.impl.protocols, impl jamesmacaulay.zelkova.impl.signal, jamesmacaulay.zelkova.impl.signal jamesmacaulay.zelkova.impl.signal}, :uses {<! cljs.core.async, >! cljs.core.async}, :defs {drop-repeats {:protocol-inline nil, :meta {:line 168, :column 7, :end-line 168, :end-column 19, :arglists (quote ([sig])), :doc "Returns a signal which relays values of `sig`, but drops repeated equal values.", :file nil}, :name jamesmacaulay.zelkova.signal/drop-repeats, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 19, :method-params ([sig]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 168, :end-line 168, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sig])), :doc "Returns a signal which relays values of `sig`, but drops repeated equal values.", :test true}, input {:protocol-inline nil, :meta {:line 17, :column 7, :end-line 17, :end-column 12, :arglists (quote ([init] [init topic] [init topic value-source])), :doc "Returns an input signal with initial value `init`. The signal propagates values\nfrom events which match some `topic`. An asynchronous `value-source` may be provided,\nwhich will be used as the default value source for the given event `topic`. `value-source`\nmay take the following forms:\n\n* a function taking a live graph and an options map, and returns a channel of values\n* a channel of values\n* a mult of some such value channel", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([init] [init topic] [init topic value-source]), :arglists ([init] [init topic] [init topic value-source]), :arglists-meta (nil nil nil)}, :file nil}, :name jamesmacaulay.zelkova.signal/input, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([init] [init topic] [init topic value-source]), :arglists ([init] [init topic] [init topic value-source]), :arglists-meta (nil nil nil)}, :method-params ([init] [init topic] [init topic value-source]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 17, :end-line 17, :max-fixed-arity 3, :fn-var true, :arglists ([init] [init topic] [init topic value-source]), :doc "Returns an input signal with initial value `init`. The signal propagates values\nfrom events which match some `topic`. An asynchronous `value-source` may be provided,\nwhich will be used as the default value source for the given event `topic`. `value-source`\nmay take the following forms:\n\n* a function taking a live graph and an options map, and returns a channel of values\n* a channel of values\n* a mult of some such value channel", :test true}, select-step {:protocol-inline nil, :meta {:line 191, :column 7, :end-line 191, :end-column 18, :arglists (quote ([init & signals-and-handlers])), :doc "Takes an initial value and a map whose keys are signals and whose values are\nreducing functions. Returns a past-dependent signal like `reductions`, except\neach signal has its own reducing function to use when that signal updates. If\nmore than one source signal updates from the same input event, then each\napplicable reducing function is called to transform the state value in the\nsame order as they are defined in `signal-handlers-map`.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(init signals-and-handlers)], :arglists [[init & signals-and-handlers]], :arglists-meta (nil)}, :file nil}, :name jamesmacaulay.zelkova.signal/select-step, :variadic true, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(init signals-and-handlers)], :arglists [[init & signals-and-handlers]], :arglists-meta (nil)}, :method-params [(init signals-and-handlers)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 191, :end-line 191, :max-fixed-arity 1, :fn-var true, :arglists [[init & signals-and-handlers]], :doc "Takes an initial value and a map whose keys are signals and whose values are\nreducing functions. Returns a past-dependent signal like `reductions`, except\neach signal has its own reducing function to use when that signal updates. If\nmore than one source signal updates from the same input event, then each\napplicable reducing function is called to transform the state value in the\nsame order as they are defined in `signal-handlers-map`.", :test true}, log {:protocol-inline nil, :meta {:line 391, :column 7, :end-line 391, :end-column 10, :arglists (quote ([sig])), :doc "A little convenience helper which logs signal values with `pr` before propagating them unchanged.", :file nil}, :name jamesmacaulay.zelkova.signal/log, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 10, :method-params ([sig]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 391, :end-line 391, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sig])), :doc "A little convenience helper which logs signal values with `pr` before propagating them unchanged.", :test true}, map {:protocol-inline nil, :meta {:line 109, :column 7, :end-line 109, :end-column 10, :arglists (quote ([f & sources])), :doc "Takes a mapping function `f` and any number of signal `sources`, and returns a\nsignal of values obtained by applying `f` to the values from the source signals.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f sources)], :arglists [[f & sources]], :arglists-meta (nil)}, :file nil}, :name jamesmacaulay.zelkova.signal/map, :variadic true, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 10, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f sources)], :arglists [[f & sources]], :arglists-meta (nil)}, :method-params [(f sources)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 109, :end-line 109, :max-fixed-arity 1, :fn-var true, :arglists [[f & sources]], :doc "Takes a mapping function `f` and any number of signal `sources`, and returns a\nsignal of values obtained by applying `f` to the values from the source signals.", :test true}, async {:protocol-inline nil, :meta {:line 211, :column 7, :end-line 211, :end-column 12, :arglists (quote ([source])), :doc "Returns an \"asynchronous\" version of `source`, splitting off a new subgraph which\ndoes not maintain consistent event ordering relative to the main graph. In exchange,\nsignals which depend on an `async` signal don't have to wait for the `source` to finish\ncomputing new values. This function is mainly useful in multithreaded environments when\nyou don't want a slow computation to block the whole graph.", :file nil}, :name jamesmacaulay.zelkova.signal/async, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 12, :method-params ([source]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 211, :end-line 211, :max-fixed-arity 1, :fn-var true, :arglists (quote ([source])), :doc "Returns an \"asynchronous\" version of `source`, splitting off a new subgraph which\ndoes not maintain consistent event ordering relative to the main graph. In exchange,\nsignals which depend on an `async` signal don't have to wait for the `source` to finish\ncomputing new values. This function is mainly useful in multithreaded environments when\nyou don't want a slow computation to block the whole graph.", :test true}, to-chan {:protocol-inline nil, :meta {:line 416, :column 7, :end-line 416, :end-column 14, :arglists (quote ([s & args])), :doc "Takes a signal `s` and returns a channel of fresh values, passing any extra `args` to\nthe `chan` constructor.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(s args)], :arglists [[s & args]], :arglists-meta (nil)}, :file nil}, :name jamesmacaulay.zelkova.signal/to-chan, :variadic true, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(s args)], :arglists [[s & args]], :arglists-meta (nil)}, :method-params [(s args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 416, :end-line 416, :max-fixed-arity 1, :fn-var true, :arglists [[s & args]], :doc "Takes a signal `s` and returns a channel of fresh values, passing any extra `args` to\nthe `chan` constructor.", :test true}, activate-when {:protocol-inline nil, :meta {:line 370, :column 7, :end-line 370, :end-column 20, :arglists (quote ([switch-sig value-sig])), :doc "Returns a transformation of `value-sig` whose entire graph of signal\ndependencies—aside from input nodes—is skipped unless `switch-sig`'s state\nis truthy. This is accomplished by walking `value-sig`'s graph and wrapping\nits input signals with `keep-when`. The intial value of a signal returned\nfrom `activate-when` is always equal to the initial value of `value-sig`.", :file nil}, :name jamesmacaulay.zelkova.signal/activate-when, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 20, :method-params ([switch-sig value-sig]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 370, :end-line 370, :max-fixed-arity 2, :fn-var true, :arglists (quote ([switch-sig value-sig])), :doc "Returns a transformation of `value-sig` whose entire graph of signal\ndependencies—aside from input nodes—is skipped unless `switch-sig`'s state\nis truthy. This is accomplished by walking `value-sig`'s graph and wrapping\nits input signals with `keep-when`. The intial value of a signal returned\nfrom `activate-when` is always equal to the initial value of `value-sig`.", :test true}, spawn {:protocol-inline nil, :meta {:line 396, :column 7, :end-line 396, :end-column 12, :arglists (quote ([s] [s opts])), :doc "Take an inert signal and produce a live, running graph.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([s] [s opts]), :arglists ([s] [s opts]), :arglists-meta (nil nil)}, :file nil}, :name jamesmacaulay.zelkova.signal/spawn, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([s] [s opts]), :arglists ([s] [s opts]), :arglists-meta (nil nil)}, :method-params ([s] [s opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 396, :end-line 396, :max-fixed-arity 2, :fn-var true, :arglists ([s] [s opts]), :doc "Take an inert signal and produce a live, running graph.", :test true}, splice {:protocol-inline nil, :meta {:line 231, :column 7, :end-line 231, :end-column 13, :arglists (quote ([setup! source] [setup! init-fn source])), :doc "Splice into the signal graph on the level of core.async channels. Takes a\n`setup!` function which is called when the `source` signal gets wired up into\na live graph. The `setup!` function is passed two arguments: a `from` channel\nand a `to` channel, in that order. The function is expected to be a consumer\nof the `from` channel and a producer on the `to` channel, and should close the\n`to` channel when the `from` channel is closed. There are no requirements for\nhow many values should be put on the `to` channel or when they should be sent.\n`splice` returns a signal with an initial returned from `init-fn`. `init-fn`\ntakes two functions, a `live-graph` and an `opts` map. If no `init-fn` is\nprovided, then the initial value of `source` is used. The returned signal\nasynchronously produces whichever values are put on the `to` channel in the\n`setup!` function.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([setup! source] [setup! init-fn source]), :arglists ([setup! source] [setup! init-fn source]), :arglists-meta (nil nil)}, :file nil}, :name jamesmacaulay.zelkova.signal/splice, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([setup! source] [setup! init-fn source]), :arglists ([setup! source] [setup! init-fn source]), :arglists-meta (nil nil)}, :method-params ([setup! source] [setup! init-fn source]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 231, :end-line 231, :max-fixed-arity 3, :fn-var true, :arglists ([setup! source] [setup! init-fn source]), :doc "Splice into the signal graph on the level of core.async channels. Takes a\n`setup!` function which is called when the `source` signal gets wired up into\na live graph. The `setup!` function is passed two arguments: a `from` channel\nand a `to` channel, in that order. The function is expected to be a consumer\nof the `from` channel and a producer on the `to` channel, and should close the\n`to` channel when the `from` channel is closed. There are no requirements for\nhow many values should be put on the `to` channel or when they should be sent.\n`splice` returns a signal with an initial returned from `init-fn`. `init-fn`\ntakes two functions, a `live-graph` and an `opts` map. If no `init-fn` is\nprovided, then the initial value of `source` is used. The returned signal\nasynchronously produces whichever values are put on the `to` channel in the\n`setup!` function.", :test true}, mergeseq {:protocol-inline nil, :meta {:line 259, :column 7, :end-line 259, :end-column 15, :arglists (quote ([sigs])), :doc "Takes a sequence of signals `sigs`, and returns a new signal which relays fresh\nvalues from all of the source signals. When more than one source has fresh values\nat the same time, the first (leftmost) signal in `sigs` will take precedence and\nthe other values will be discarded. The initial value of the returned signal is\nequal to the initial value of the first source signal.", :file nil}, :name jamesmacaulay.zelkova.signal/mergeseq, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 15, :method-params ([sigs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 259, :end-line 259, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sigs])), :doc "Takes a sequence of signals `sigs`, and returns a new signal which relays fresh\nvalues from all of the source signals. When more than one source has fresh values\nat the same time, the first (leftmost) signal in `sigs` will take precedence and\nthe other values will be discarded. The initial value of the returned signal is\nequal to the initial value of the first source signal.", :test true}, pipeline {:protocol-inline nil, :meta {:line 63, :column 7, :end-line 63, :end-column 15, :arglists (quote ([xform base sig])), :doc "Takes a stateless transducer `xform`, a fallback value `base`, and a signal\n`sig`. Returns a new signal which pipes values from `sig` through `xform`.\nBecause transducers may filter out values, you must provide a `base` which will\nbe used as the derived signal's initial value if the initial value of `sig` ends\nup being filtered. If multiple values are emitted from the transduction of the\ninitial value of `sig`, then the initial value of the new signal will be the\n_last_ of those emitted. Stateful transducers will give unexpected results and\nare not supported.", :file nil}, :name jamesmacaulay.zelkova.signal/pipeline, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 15, :method-params ([xform base sig]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 63, :end-line 63, :max-fixed-arity 3, :fn-var true, :arglists (quote ([xform base sig])), :doc "Takes a stateless transducer `xform`, a fallback value `base`, and a signal\n`sig`. Returns a new signal which pipes values from `sig` through `xform`.\nBecause transducers may filter out values, you must provide a `base` which will\nbe used as the derived signal's initial value if the initial value of `sig` ends\nup being filtered. If multiple values are emitted from the transduction of the\ninitial value of `sig`, then the initial value of the new signal will be the\n_last_ of those emitted. Stateful transducers will give unexpected results and\nare not supported.", :test true}, foldp {:protocol-inline nil, :meta {:line 154, :column 7, :end-line 154, :end-column 12, :arglists (quote ([f base source])), :doc "Create a past-dependent signal (\"fold into the past\"). The values of a `foldp`\nsignal are obtained by calling `f` with two arguments: the current value of the\n`source` signal, and the previous value of the new `foldp` signal (acting as the\n\"accumulator\"). `init` provides the initial value of the new signal, and\ntherefore acts as the seed accumulator.", :file nil}, :name jamesmacaulay.zelkova.signal/foldp, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 12, :method-params ([f base source]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 154, :end-line 154, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f base source])), :doc "Create a past-dependent signal (\"fold into the past\"). The values of a `foldp`\nsignal are obtained by calling `f` with two arguments: the current value of the\n`source` signal, and the previous value of the new `foldp` signal (acting as the\n\"accumulator\"). `init` provides the initial value of the new signal, and\ntherefore acts as the seed accumulator.", :test true}, take-nothing {:protocol-inline nil, :meta {:line 49, :column 8, :end-line 49, :end-column 20, :private true, :arglists (quote ([rf])), :file nil}, :private true, :name jamesmacaulay.zelkova.signal/take-nothing, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 20, :method-params ([rf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 49, :end-line 49, :max-fixed-arity 1, :fn-var true, :arglists (quote ([rf])), :test true}, mapseq {:protocol-inline nil, :meta {:line 88, :column 7, :end-line 88, :end-column 13, :arglists (quote ([f sources])), :doc "Takes a mapping function `f` and a sequence of signal `sources`, and returns a\nsignal of values obtained by applying `f` to the values from the source signals.", :file nil}, :name jamesmacaulay.zelkova.signal/mapseq, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 13, :method-params ([f sources]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 88, :end-line 88, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f sources])), :doc "Takes a mapping function `f` and a sequence of signal `sources`, and returns a\nsignal of values obtained by applying `f` to the values from the source signals.", :test true}, reductions {:protocol-inline nil, :meta {:line 179, :column 7, :end-line 179, :end-column 17, :arglists (quote ([f source] [f init source])), :doc "Create a past-dependent signal like `foldp`, with two differences:\n* calls `f` with the arguments reversed to align with Clojure: the first\nargument is the accumulator, the second is the current value of `source`.\n* if `init` is omitted, the initial value of the new signal will be obtained by\ncalling `f` with no arguments.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f source] [f init source]), :arglists ([f source] [f init source]), :arglists-meta (nil nil)}, :file nil}, :name jamesmacaulay.zelkova.signal/reductions, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f source] [f init source]), :arglists ([f source] [f init source]), :arglists-meta (nil nil)}, :method-params ([f source] [f init source]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 179, :end-line 179, :max-fixed-arity 3, :fn-var true, :arglists ([f source] [f init source]), :doc "Create a past-dependent signal like `foldp`, with two differences:\n* calls `f` with the arguments reversed to align with Clojure: the first\nargument is the accumulator, the second is the current value of `source`.\n* if `init` is omitted, the initial value of the new signal will be obtained by\ncalling `f` with no arguments.", :test true}, sample-on {:protocol-inline nil, :meta {:line 287, :column 7, :end-line 287, :end-column 16, :arglists (quote ([sampler-sig value-sig])), :doc "Sample the current value of `value-sig` every time `sampler-sig` updates with a\nfresh value. For example, `(sample-on mouse/clicks mouse/position)` returns a signal\nof click positions.", :file nil}, :name jamesmacaulay.zelkova.signal/sample-on, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 16, :method-params ([sampler-sig value-sig]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 287, :end-line 287, :max-fixed-arity 2, :fn-var true, :arglists (quote ([sampler-sig value-sig])), :doc "Sample the current value of `value-sig` every time `sampler-sig` updates with a\nfresh value. For example, `(sample-on mouse/clicks mouse/position)` returns a signal\nof click positions.", :test true}, constant {:protocol-inline nil, :meta {:line 56, :column 7, :end-line 56, :end-column 15, :arglists (quote ([x])), :doc "Returns a constant signal of the given value.", :file nil}, :name jamesmacaulay.zelkova.signal/constant, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 56, :end-line 56, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a constant signal of the given value.", :test true}, drop-if {:protocol-inline nil, :meta {:line 342, :column 7, :end-line 342, :end-column 14, :arglists (quote ([pred sig] [pred base sig])), :doc "Like `keep-if`, but drops values which match the predicate.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([pred sig] [pred base sig]), :arglists ([pred sig] [pred base sig]), :arglists-meta (nil nil)}, :file nil}, :name jamesmacaulay.zelkova.signal/drop-if, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([pred sig] [pred base sig]), :arglists ([pred sig] [pred base sig]), :arglists-meta (nil nil)}, :method-params ([pred sig] [pred base sig]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 342, :end-line 342, :max-fixed-arity 3, :fn-var true, :arglists ([pred sig] [pred base sig]), :doc "Like `keep-if`, but drops values which match the predicate.", :test true}, pipe-to-atom {:protocol-inline nil, :meta {:line 401, :column 7, :end-line 401, :end-column 19, :arglists (quote ([x] [x atm] [x atm ks])), :doc "Pipes fresh values from a live graph into an atom. If `x` is a signal, it is `spawn`ed\nas a live graph first. If no atom is provided, then a new atom is created which takes its\ninitial value from that of the given signal or graph. If an existing atom is provided along\nwith a sequence of keys `ks`, then fresh values will be inserted into the atom's value using\n`swap!` with `assoc-in`. If `ks` is not present, then the whole atom value is replaced with\n`reset!`.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([x] [x atm] [x atm ks]), :arglists ([x] [x atm] [x atm ks]), :arglists-meta (nil nil nil)}, :file nil}, :name jamesmacaulay.zelkova.signal/pipe-to-atom, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([x] [x atm] [x atm ks]), :arglists ([x] [x atm] [x atm ks]), :arglists-meta (nil nil nil)}, :method-params ([x] [x atm] [x atm ks]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 401, :end-line 401, :max-fixed-arity 3, :fn-var true, :arglists ([x] [x atm] [x atm ks]), :doc "Pipes fresh values from a live graph into an atom. If `x` is a signal, it is `spawn`ed\nas a live graph first. If no atom is provided, then a new atom is created which takes its\ninitial value from that of the given signal or graph. If an existing atom is provided along\nwith a sequence of keys `ks`, then fresh values will be inserted into the atom's value using\n`swap!` with `assoc-in`. If `ks` is not present, then the whole atom value is replaced with\n`reset!`.", :test true}, keep-if-msg-xform {:protocol-inline nil, :meta {:line 316, :column 8, :end-line 316, :end-column 25, :private true, :arglists (quote ([pred])), :file nil}, :private true, :name jamesmacaulay.zelkova.signal/keep-if-msg-xform, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 25, :method-params ([pred]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 316, :end-line 316, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pred])), :test true}, count-if {:protocol-inline nil, :meta {:line 306, :column 7, :end-line 306, :end-column 15, :arglists (quote ([pred sig])), :doc "Like `count`, but only increments the counter if the fresh value emitted from `sig`\nsatisfies the predicate funtion `pred`. For example, `(count-if odd? numbers)` returns\na signal of how many times the `numbers` signal emitted an odd number.", :file nil}, :name jamesmacaulay.zelkova.signal/count-if, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 15, :method-params ([pred sig]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 306, :end-line 306, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred sig])), :doc "Like `count`, but only increments the counter if the fresh value emitted from `sig`\nsatisfies the predicate funtion `pred`. For example, `(count-if odd? numbers)` returns\na signal of how many times the `numbers` signal emitted an odd number.", :test true}, template {:protocol-inline nil, :meta {:line 115, :column 7, :end-line 115, :end-column 15, :arglists (quote ([signal-map])), :doc "Takes a map whose values are signals, to be used as a template. Returns a new\nsignal whose values are maps of the same form as `signal-map`, but with the current\nvalue of each signal in place of the signal itself.", :file nil}, :name jamesmacaulay.zelkova.signal/template, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 15, :method-params ([signal-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 115, :end-line 115, :max-fixed-arity 1, :fn-var true, :arglists (quote ([signal-map])), :doc "Takes a map whose values are signals, to be used as a template. Returns a new\nsignal whose values are maps of the same form as `signal-map`, but with the current\nvalue of each signal in place of the signal itself.", :test true}, drop-when {:protocol-inline nil, :meta {:line 363, :column 7, :end-line 363, :end-column 16, :arglists (quote ([switch-sig value-sig] [switch-sig base value-sig])), :doc "Like `keep-when`, but only relays values when `switch-sig` is falsy.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([switch-sig value-sig] [switch-sig base value-sig]), :arglists ([switch-sig value-sig] [switch-sig base value-sig]), :arglists-meta (nil nil)}, :file nil}, :name jamesmacaulay.zelkova.signal/drop-when, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([switch-sig value-sig] [switch-sig base value-sig]), :arglists ([switch-sig value-sig] [switch-sig base value-sig]), :arglists-meta (nil nil)}, :method-params ([switch-sig value-sig] [switch-sig base value-sig]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 363, :end-line 363, :max-fixed-arity 3, :fn-var true, :arglists ([switch-sig value-sig] [switch-sig base value-sig]), :doc "Like `keep-when`, but only relays values when `switch-sig` is falsy.", :test true}, combine {:protocol-inline nil, :meta {:line 281, :column 7, :end-line 281, :end-column 14, :arglists (quote ([sigs])), :doc "Combines a sequence of signals into a signal of vectors. Equivalent to\n`(signal/map vector sig1, sig2, ...)`", :file nil}, :name jamesmacaulay.zelkova.signal/combine, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 14, :method-params ([sigs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 281, :end-line 281, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sigs])), :doc "Combines a sequence of signals into a signal of vectors. Equivalent to\n`(signal/map vector sig1, sig2, ...)`", :test true}, keep-when {:protocol-inline nil, :meta {:line 349, :column 7, :end-line 349, :end-column 16, :arglists (quote ([switch-sig value-sig] [switch-sig base value-sig])), :doc "Returns a new signal which relays values from `value-sig`, but only when the current\nvalue of `switch-sig` is truthy.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([switch-sig value-sig] [switch-sig base value-sig]), :arglists ([switch-sig value-sig] [switch-sig base value-sig]), :arglists-meta (nil nil)}, :file nil}, :name jamesmacaulay.zelkova.signal/keep-when, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([switch-sig value-sig] [switch-sig base value-sig]), :arglists ([switch-sig value-sig] [switch-sig base value-sig]), :arglists-meta (nil nil)}, :method-params ([switch-sig value-sig] [switch-sig base value-sig]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 349, :end-line 349, :max-fixed-arity 3, :fn-var true, :arglists ([switch-sig value-sig] [switch-sig base value-sig]), :doc "Returns a new signal which relays values from `value-sig`, but only when the current\nvalue of `switch-sig` is truthy.", :test true}, merge {:protocol-inline nil, :meta {:line 272, :column 7, :end-line 272, :end-column 12, :arglists (quote ([& sigs])), :doc "Takes any number of source signals `sigs`, and returns a new signal which relays\nfresh values from all of the source signals. When more than one source has fresh values\nat the same time, the first (leftmost) signal will take precedence and the other values\nwill be discarded. The initial value of the returned signal is equal to the initial\nvalue of the first source signal.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(sigs)], :arglists [[& sigs]], :arglists-meta (nil)}, :file nil}, :name jamesmacaulay.zelkova.signal/merge, :variadic true, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(sigs)], :arglists [[& sigs]], :arglists-meta (nil)}, :method-params [(sigs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 272, :end-line 272, :max-fixed-arity 0, :fn-var true, :arglists [[& sigs]], :doc "Takes any number of source signals `sigs`, and returns a new signal which relays\nfresh values from all of the source signals. When more than one source has fresh values\nat the same time, the first (leftmost) signal will take precedence and the other values\nwill be discarded. The initial value of the returned signal is equal to the initial\nvalue of the first source signal.", :test true}, indexed-updates {:protocol-inline nil, :meta {:line 125, :column 7, :end-line 125, :end-column 22, :arglists (quote ([signal-map])), :doc "Takes a map whose values are signals, to be used as a template. Returns a new\nsignal whose values are maps that include an entry for every signal in\n`signal-map` with a fresh value. For example, assuming that `signal-map` is:\n\n    {:a sig-a\n     :b sig-b\n     :c sig-c}\n\nThen when `sig-a` has a fresh value of \"foo\", `sig-b`'s value is cached, and\n`sig-c` has a fresh value of \"bar\", then the `indexed-updates` signal would\nemit `{:a \"foo\" :c \"bar\"}. When none of the signals have fresh values, no\nvalue is emitted from the `indexed-updates` signal. This means that this signal\nnever emits an empty map.", :file nil}, :name jamesmacaulay.zelkova.signal/indexed-updates, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 22, :method-params ([signal-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 125, :end-line 125, :max-fixed-arity 1, :fn-var true, :arglists (quote ([signal-map])), :doc "Takes a map whose values are signals, to be used as a template. Returns a new\nsignal whose values are maps that include an entry for every signal in\n`signal-map` with a fresh value. For example, assuming that `signal-map` is:\n\n    {:a sig-a\n     :b sig-b\n     :c sig-c}\n\nThen when `sig-a` has a fresh value of \"foo\", `sig-b`'s value is cached, and\n`sig-c` has a fresh value of \"bar\", then the `indexed-updates` signal would\nemit `{:a \"foo\" :c \"bar\"}. When none of the signals have fresh values, no\nvalue is emitted from the `indexed-updates` signal. This means that this signal\nnever emits an empty map.", :test true}, write-port {:protocol-inline nil, :meta {:line 35, :column 7, :end-line 35, :end-column 17, :arglists (quote ([init] [init topic])), :doc "Takes an `init` value and an optional `topic`, and returns an input signal\n  which satisfies core.async's `WritePort` protocol. This allows you to put\n  values onto the signal as if it were a channel. If the `write-port` is being\n  used in multiple live graphs, each value put onto the `write-port` is\n  sent to all graphs.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([init] [init topic]), :arglists ([init] [init topic]), :arglists-meta (nil nil)}, :file nil}, :name jamesmacaulay.zelkova.signal/write-port, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([init] [init topic]), :arglists ([init] [init topic]), :arglists-meta (nil nil)}, :method-params ([init] [init topic]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 35, :end-line 35, :max-fixed-arity 2, :fn-var true, :arglists ([init] [init topic]), :doc "Takes an `init` value and an optional `topic`, and returns an input signal\n  which satisfies core.async's `WritePort` protocol. This allows you to put\n  values onto the signal as if it were a channel. If the `write-port` is being\n  used in multiple live graphs, each value put onto the `write-port` is\n  sent to all graphs.", :test true}, count {:protocol-inline nil, :meta {:line 299, :column 7, :end-line 299, :end-column 12, :arglists (quote ([sig])), :doc "Returns a signal whose values are the number of fresh values emitted so far from\n`sig`. Repeated equal values will be counted so long as they are fresh, so if you\ndon't want to count repeats then you need to `(count (drop-repeats sig))` instead.", :file nil}, :name jamesmacaulay.zelkova.signal/count, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 12, :method-params ([sig]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 299, :end-line 299, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sig])), :doc "Returns a signal whose values are the number of fresh values emitted so far from\n`sig`. Repeated equal values will be counted so long as they are fresh, so if you\ndon't want to count repeats then you need to `(count (drop-repeats sig))` instead.", :test true}, keep-if {:protocol-inline nil, :meta {:line 324, :column 7, :end-line 324, :end-column 14, :arglists (quote ([pred sig] [pred base sig])), :doc "Returns a signal which relays values from `sig`, but discards any which don't match\nthe given predicate function `pred`. If a `base` value is provided, it will be the\ninitial value of the returned signal if the initial value of `sig` does not match the\npredicate. If no `base` is provided then the returned signal will always have the\nsame initial value as `sig`, even if it does not match the predicate.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([pred sig] [pred base sig]), :arglists ([pred sig] [pred base sig]), :arglists-meta (nil nil)}, :file nil}, :name jamesmacaulay.zelkova.signal/keep-if, :variadic false, :file "mario/jamesmacaulay/zelkova/signal.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([pred sig] [pred base sig]), :arglists ([pred sig] [pred base sig]), :arglists-meta (nil nil)}, :method-params ([pred sig] [pred base sig]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 324, :end-line 324, :max-fixed-arity 3, :fn-var true, :arglists ([pred sig] [pred base sig]), :doc "Returns a signal which relays values from `sig`, but discards any which don't match\nthe given predicate function `pred`. If a `base` value is provided, it will be the\ninitial value of the returned signal if the initial value of `sig` does not match the\npredicate. If no `base` is provided then the returned signal will always have the\nsame initial value as `sig`, even if it does not match the predicate.", :test true}}, :require-macros {cljs.core.async.macros cljs.core.async.macros}, :cljs.analyzer/constants {:seen #{:event-sources :jamesmacaulay.zelkova.signal/source :meta :sources :events :jamesmacaulay.zelkova.signal/async :write-port-channel :init-fn :relayed-event-topic :jamesmacaulay.zelkova.signal/splice :msg-xform :deps}, :order [:init-fn :relayed-event-topic :event-sources :write-port-channel :sources :msg-xform :events :jamesmacaulay.zelkova.signal/async :deps :jamesmacaulay.zelkova.signal/splice :meta :jamesmacaulay.zelkova.signal/source]}, :doc "This is Zelkova's core namespace."}